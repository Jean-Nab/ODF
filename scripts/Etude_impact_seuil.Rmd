---
title: 'Etude : Effet du seuil de détermination des espèces communes'
author: "Jean N"
date: "12/05/2021"
output: html_document
---
<style>body {text-align: justify}</style>

## L'indice de détermination des espèces "communes"

Pour déterminer les espèces communes, j'ai décider d'utiliser la théorie des graphs afin de pouvoir utiliser les départements comme informations de localisation des observations.

<center><u>*Fig 1. Illustration du réseau -- package igraph*</u></center>\  
![](C:/git/ODF/output/Etude_impact_seuil/illustration_reseau.png)


J'ai formé un graph mettant en relation les espèces selon les départements où ils ont été observé (Cf. fig 1). Afin de déterminer les espèces communes j'ai utilisé le <u>**degré**</u>, qui correspond au nombre de noeud (ici, le nombre de départements) auxquels une espèce est liée. Plus l'espèce a été observé dans un grand nombre de départements, plus son degré est élevé.\  

Je pars du principe qu'une espèce commune est présente dans un plus grand nombre de département et le **seuil** correspond aux quantiles de la distribution de ces degrés.

Dans le cadre de cette étude j'ai utilisé commes quantiles *0.50*,*0.55*,*0.60*,*0.65*,*0.70*,*0.75*,*0.80*,*0.85*,*0.90*,*0.95*,*0.96*,*0.97*,*0.98*,*0.99*\  

>  *NB* : Il existe d'autres indices de mesures se basant sur les graphs qui pourraient être plus appropriés [Table 1. Lau et al., 2017](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/ecs2.1900)

\  \  \  


### <u>Rappel du processus de détermination</u>

Pour rappel, la détermination des espèces "communes" est faite à partir d'un sous-ensemble des observtations réalisé par les plus gros contributeurs d'EPOC, c'est-à-dire ceux ayant réalisé au moins 1% des listes (~ 580 listes).

<center><u>*Fig 2. Schéma conceptuel pour la détermination des espèces communes / analyse comportements des obsevateurs*</u></center>\  
![](C:/git/ODF/output/Etude_impact_seuil/schema_simu.png)

*  Comme le montre la figure 2, à partir de ce sous-ensemble des données j'ai pu :
    + Faire la distinction entre les espèces communes/non-communes via la théorie des graphs
    + Simuler la réalisation d'EPOC (de 1 à 35 espèces identifées par EPOC) à partir des fréquences d'occurrences
    
C'est avec ces deux éléments que j'ai pu former les "Courbes d'évolution de la composition communs/non-communs" dans les listes EPOC\  


>  Dans mon script, j'ai former plusieures matrices de population selon le nombre d'individus identifiés (*i.e*. M1 pour 1 espèce, M3 pour 3, ...). A voir si cette méthode ne s'éloigne pas de la réalité, dans le sens où il y'a **une** population d'oiseaux présent sur le territoire. 

```{r exemple_matrice_pop, eval=FALSE,echo=TRUE}
# Exemple du code (nom de variables modifiees)

  Mat1 <- c() ; Mat2 <- c()
  ...
  Mat34 <- c() ; Mat35 <- c()

for(i in 1:10000){
      Mat1 <- append(Mat1,as.character(sample(x = TABLE_GRDS_CONTRIB$Nom_espece, size=1, 
                                              replace=FALSE, prob = TABLE_GRDS_CONTRIB$freq_occurrence)))
      Mat2 <- append(Mat2,as.character(sample(x = TABLE_GRDS_CONTRIB$Nom_espece, size=2, 
                                              replace=FALSE, prob = TABLE_GRDS_CONTRIB$freq_occurrence)))
      
      ....
      
      Mat34 <- append(Mat34,as.character(sample(x = TABLE_GRDS_CONTRIB$Nom_espece, size=34, 
                                                replace=FALSE, prob = TABLE_GRDS_CONTRIB$freq_occurrence)))
      Mat35 <- append(Mat35,as.character(sample(x = TABLE_GRDS_CONTRIB$Nom_espece, size=35, 
                                                replace=FALSE, prob = TABLE_GRDS_CONTRIB$freq_occurrence)))
    }
```

***

```{r load_packages, include=FALSE}
# chemin
setwd("C:/git/ODF")

# packages
library(sf)
library(ggplot2)
library(tidyverse)
library(reshape2)
library(dplyr)
library(igraph) # theorie des graphs
library(data.table)
```

```{r upload_formating_data, include=FALSE}
# upload des data ----
  epoc.oiso <- data.table::fread(file = "C:/git/ODF/data/ODF_epoc_communaute.txt",header=T,stringsAsFactors = F,
                     encoding="UTF-8",quote="")
  epoc.bary <- data.table::fread(file = "C:/git/ODF/data/ODF_epoc_barycentre.txt",header=T,stringsAsFactors = F,
                     encoding="UTF-8",quote="")
  epoc.obs <- data.table::fread(file = "C:/git/ODF/data/ODF_epoc_observation.txt",header=T,stringsAsFactors = F,
                    encoding="UTF-8",quote="")
  
  eco.reg <- st_transform(st_read("C:/git/epoc/data/france_ecoregions_v3.shp"),crs=2154)
  eco.reg.buf <- st_buffer(eco.reg,dist = 25000)
  
  fra.adm.l93 <- st_transform(st_read(dsn = "C:/Users/Travail/Desktop/Ressource QGis/france/adm/FRA_adm0.shp"),crs=2154)
  
  # Table des categories d'especes selon leur niveau de rarete (dire d'expert : Jeremy dupuy)
    cate.esp <- read.csv(file = "C:/git/epoc/data/listes_especes_all_epoc_JD.csv",header=T,sep=";",dec=",",encoding = "UTF-8")
    cate.esp2 <- cate.esp[,c("Nom_espece","Decision")]

# retrait Liste selon horaire : 5-20 // Mois 01/03 - 31/07 ----
# detection des ID_liste compris dans les filtres
  in_filtre <- unique(epoc.obs[-which(epoc.obs$Heure_de_debut < 5 | epoc.obs$Heure_de_debut >20),"ID_liste"]) # retrait des listes realise entre 20h-5h
  in_filtre <- intersect(in_filtre, unique(epoc.obs[epoc.obs$Mois %in% c(3:7)  ,"ID_liste"])) # retrait des listes faites en dehors de mars-juillet
  in_filtre <- in_filtre[[1]] # conversion en vecteur des ID_liste
  
  epoc.oiso <- subset(epoc.oiso, epoc.oiso$ID_liste %in% in_filtre)
  epoc.bary <- subset(epoc.bary, epoc.bary$ID_liste %in% in_filtre)
  epoc.obs <- subset(epoc.obs, epoc.obs$ID_liste %in% in_filtre)
  
# objet spatiaux
  epoc.bary_sf <- st_as_sf(epoc.bary,coords=c("X_Lambert93_m","Y_Lambert93_m"),crs=2154)

```

```{r source_fonction_ecoregion, include=FALSE}
determination_communs_by_regions_ETUDE_SEUIL <- function(dtf.reg1,prob.minimum.sp,seuil){
  
  reg1.tmp <- dtf.reg1
  PROB.MINIMUM.SP <- prob.minimum.sp
  
  id.list.reg <- reg1.tmp[reg1.tmp[2] == 1,"ID_liste"] # detection des id de liste detectee dans cette region  
  
  # recuperation des observation liee aux id de liste ----
    det.list.byreg.epoc_oiso <- epoc.oiso$ID_liste %in% id.list.reg # detection des lignes
    epoc.oiso.region <- epoc.oiso[which(det.list.byreg.epoc_oiso == TRUE),] # formation du dtf associee aux lignes detectee
    
  
  # formation du dtf permettant de detecter les champions de la region ----
    list.byregion <- aggregate(diversite ~ Observateur + ID_liste,
                               data = epoc.oiso.region,
                               FUN = sum)
    
    list.byregion$nb_liste <- 1
    
    observateur.byregion <- aggregate(nb_liste ~ Observateur, data=list.byregion,sum)
    observateur.byregion$part_liste_in_region <- observateur.byregion$nb_liste / sum(observateur.byregion$nb_liste)
    
  # selection des champions selon nb listes realise dans la l'ecoregion
    select.champ <- as.vector(observateur.byregion[which(observateur.byregion$nb_liste >= 50),"Observateur"])
  
  
  # determination des especes communes a partir des champions -----
    # Recuperation de l'ensemble des obs fait par les champions dans la region -----
      det.champ.epoc.oiso.region <- epoc.oiso.region$Observateur %in% select.champ # detection des observations realiser par les champions
      
      champ.oiso.region <- epoc.oiso.region[which(det.champ.epoc.oiso.region == TRUE),] # formation du dtf d'observation des champions
      
    # Ajout de l'information departementales
      champ.oiso.region <- left_join(champ.oiso.region,epoc.bary[,c("ID_liste","Departement")])
      
    # Determination especes communes --> Degrees : Theories des graphs ----
      champ.cortege.region <- graph.data.frame(champ.oiso.region[,c("Nom_espece","Departement")], directed = F) # ou ID_liste
      
      # calcul d'indices - degree
        cortege_degree.region <- degree(champ.cortege.region,normalized = T)
      
      # classement des especes (= retrait des nodes departements)
        cortege_degree.region2 <- cortege_degree.region[which(names(cortege_degree.region) %in% unique(champ.oiso$Nom_espece))]
        name.oiso.com.region <- names(cortege_degree.region2[which(cortege_degree.region2 > as.numeric(quantile(cortege_degree.region2,seuil)))]) 
      
    # Distinction communs/non-communs -----
      champ.oiso.region$communs <- 0
      champ.oiso.region[which(champ.oiso.region$Nom_espece %in% name.oiso.com.region),"communs"] <- 1
      
      
      
  # Application du flag especes communes sur toutes les observations de la regions (epoc.oiso.region) -----
    det.obs.oiso.communs.byregion <- epoc.oiso.region$Nom_espece %in% name.oiso.com.region
    
    epoc.oiso.region$communs <- 0 # Vs cas ou une espece n'est pas detecte par les champions (=> ici, on la considere comme rare)
    
    epoc.oiso.region[which(det.obs.oiso.communs.byregion == TRUE),"communs"] <- 1 # flag des oiseaux consideres comme communs par les champions  
    
  
  
  # PREPARATIF du flagging des listes (= calcul part d'espece communes / presence d'au moins une espece communes) -----
  epoc.oiso.region$communs_logical <- as.logical(epoc.oiso.region$communs) # preparatif pour l'aggregate en any
  
  # flag de la part d'espece communes
  flag.prep.part.comm <- aggregate(communs ~ ID_liste, data = epoc.oiso.region, sum)
  colnames(flag.prep.part.comm) <- c("ID_liste","nb_communs")
  
  # flag presence d'au moins une espece commune dans la liste
  flag.prep.least_1_comm <- aggregate(communs_logical ~ ID_liste, data = epoc.oiso.region, any)
  colnames(flag.prep.least_1_comm) <- c("ID_liste","least_1_communs")
  
  # join au dtf (list.byregion + flagging des listes)
  list.byregion <- plyr::join(list.byregion,flag.prep.part.comm,by="ID_liste")
  list.byregion$part_communs <- list.byregion$nb_communs / list.byregion$diversite
  
  list.byregion <- plyr::join(list.byregion,flag.prep.least_1_comm,by="ID_liste")
  
  
  
  
  
  # FLAGGING -----
  # Flag many_rare (Liste a forte diversite [>4 especes] avec que des especes rares)
  list.byregion$flag_many_rare <- 0
  
  id.list.rare <- which(list.byregion$diversite >= PROB.MINIMUM.SP & list.byregion$least_1_communs == FALSE)
  list.byregion[id.list.rare,"flag_many_rare"] <- 1
  
  # Flag only_rare_low_dic (Liste de faible diversite [< 4 especes] avec que des especes rares)
  list.byregion$flag_only_rare_low_div <- 0
  
  id.list.rare.low <- which(list.byregion$diversite < PROB.MINIMUM.SP & list.byregion$least_1_communs == FALSE)
  list.byregion[id.list.rare.low,"flag_only_rare_low_div"] <- 1
  
  # Flag scarce_communs (part d'especes communes moins importante que l'attendue)
  list.byregion$flag_scarce_commun <- 0
  
  comp.communs <- plyr::join(list.byregion[,c("ID_liste","diversite","part_communs")],tab.qt.global.part,by="diversite")
  list.emp_th <- comp.communs[which(comp.communs$part_communs <= comp.communs$borne_inf),"ID_liste"]
  
  id.list.less.comm <- list.byregion$ID_liste %in% list.emp_th
  list.byregion[which(id.list.less.comm == TRUE),"flag_scarce_commun"] <- 1
  
  # Flag premiere espece rencontree
  # ajout des categories <=> evaluation de jérémy
  epoc.oiso.region <- plyr::join(epoc.oiso.region,cate.esp2,by="Nom_espece") # join des categories de rarete experte selon le nom d'espece
  epoc.oiso.region[which(is.na(epoc.oiso.region$Decision)),"Decision"] <- 1 # cas ou une espece ne serait pas identifie (-> presummer rare)
  
  # incrementation -> detection de la 1ere observation de chaque liste
  epoc.oiso.cate_dt <- data.table::data.table(epoc.oiso.region)
  epoc.oiso.cate_dt <- epoc.oiso.cate_dt[, group_increment := 1:.N, by = "ID_liste"]
  epoc.oiso.region <- as.data.frame(epoc.oiso.cate_dt)
  
  # selection de la 1ere observation de chaque liste
  first.obs <- which(epoc.oiso.region$group_increment == 1)
  list.oiso.cate.byregion <- epoc.oiso.region[first.obs,c("ID_liste","Observateur","Nom_espece","Decision","group_increment")]   
  
  # add flag communs/rare d'une espece
  det.list.oiso.cate.communs.byregion <- list.oiso.cate.byregion$Nom_espece %in% name.oiso.com.region
  
  list.oiso.cate.byregion$communs <- 0
  list.oiso.cate.byregion[which(det.list.oiso.cate.communs.byregion == TRUE),"communs"] <- 1
  
  list.oiso.cate.byregion$flag_first_obs_unusual <- 0
  list.oiso.cate.byregion[list.oiso.cate.byregion$Decision == 1 | list.oiso.cate.byregion$Decision == 2,"flag_first_obs_unusual"] <- 1
  list.oiso.cate.byregion[list.oiso.cate.byregion$Decision == 3 & list.oiso.cate.byregion$communs == 0
                          ,"flag_first_obs_unusual"] <- 1
  
  list.byregion <- plyr::join(list.byregion,list.oiso.cate.byregion[,c("ID_liste","flag_first_obs_unusual")],by="ID_liste")
  
  
  # Regroupement des flags (fait par listes) sur les observateurs -----
  observateur.flag.many.byregion <- aggregate(flag_many_rare ~ Observateur,
                                              data = list.byregion,
                                              FUN = sum)
  
  observateur.flag.low.byregion <- aggregate(flag_only_rare_low_div ~ Observateur,
                                             data = list.byregion,
                                             FUN = sum)
  
  observateur.flag.scarce.byregion <- aggregate(flag_scarce_commun ~ Observateur,
                                                data = list.byregion,
                                                FUN = sum)
  
  observateur.flag.first.byregion <- aggregate(flag_first_obs_unusual ~ Observateur,
                                               data = list.oiso.cate.byregion,
                                               FUN = sum)
  
  # ajout de ces informations sur le dtf des observateurs
  observateur.byregion <- plyr::join(observateur.byregion,observateur.flag.many.byregion,by="Observateur")
  observateur.byregion <- plyr::join(observateur.byregion,observateur.flag.low.byregion,by="Observateur")
  observateur.byregion <- plyr::join(observateur.byregion,observateur.flag.scarce.byregion,by="Observateur")
  observateur.byregion <- plyr::join(observateur.byregion,observateur.flag.first.byregion,by="Observateur")
  
  
  
  
  
  # Return des dtf dans l'environnement global ----
  
  # indexation selon la region (nouvelle colonne $regions dans chaque dtf de sortie de fonction)
  
  observateur.byregion$regions <- colnames(reg1.tmp[2])
  list.byregion$regions <- colnames(reg1.tmp[2])
  champ.oiso.region$regions <- colnames(reg1.tmp[2])
  
  # enregistrement des variables dans l'environnement global
  var.reg <- paste0("observateur.reg.",abbreviate(colnames(reg1.tmp[2])))
  assign(x = var.reg, value = observateur.byregion,
         envir = globalenv())
  
  var.reg2 <- paste0("list.reg.",abbreviate(colnames(reg1.tmp[2])))
  assign(x = var.reg2, value = list.byregion,
         envir = globalenv())
  
  var.reg3 <- paste0("oiso.reg.",abbreviate(colnames(reg1.tmp[2])))
  assign(x = var.reg3, value = champ.oiso.region[,c("Nom_espece","Nom_latin","communs","regions")],
         envir = globalenv())
  
  
  
  
}

```

```{r analyse_prelim,include = FALSE,message = FALSE,cache=TRUE}
# ANALYSE PRELIMINAIRE - Nb d'obs/epoc/observateur par ecoregions----
  # formation / conversion des objets spatiaux
    epoc.obs_sf <- st_as_sf(epoc.obs,coords=c("X_Lambert93_m","Y_Lambert93_m"),crs=2154)
  
  # exploration preleminaire (-> table)
    table.preli <- st_intersects(x=eco.reg,y=epoc.obs_sf,sparse = F)
    table.preli <- t(table.preli)
    table.preli.res <- colSums(table.preli) ; table.preli.res
    
    eco.nam <- as.character(eco.reg$ECO_NAME) # recuperation du nom des ecoregions
    names(table.preli.res) <- eco.nam
    
    table.preli_dtf <- as.data.frame(table.preli) ; colnames(table.preli_dtf) <- eco.nam
  
  # ggplot() + geom_sf(data=eco.reg,aes(fill=ECO_NAME))
  
  # recolte info par biomes (nb obs / nb listes / nb observateurs)
    reg.nam <- c()
    nb.list <- c()
    nb.obs <- c()
    obs <- c()
    
    i <- 1
    
    while(i <= ncol(table.preli)){
      
      dtf.tmp <- table.preli[,i]
      logi.dtf <- which(dtf.tmp == TRUE) 
      
      sf.tmp <- epoc.obs_sf[logi.dtf,]
      
      #vec.tmp <- c(eco.nam[i],nrow(sf.tmp),length(unique(sf.tmp$ID_liste)),length(unique(sf.tmp$Observateur)))
      reg.nam <- append(reg.nam,eco.nam[i])
      nb.list <- append(nb.list, length(unique(sf.tmp$ID_liste)))
      nb.obs <- append(nb.obs, length(unique(sf.tmp$Observateur)))
      obs <- append(obs, nrow(sf.tmp))
      
      
      cat(i)
      i <- i+1
    }
  
  # mise en forme des donnees extraites par ecoregions
    resul <- matrix(c(reg.nam,nb.list,nb.obs,obs),nrow=ncol(table.preli),byrow=F)
    resul <- data.frame(resul)
    colnames(resul) <- c("nom_ecoregion","nb_listes","nb_observateurs","nb_observations")
```

```{r boucle_multi_seuil, include=FALSE,message=FALSE,echo = FALSE, results="hide",cache=TRUE}

# FORMATION VECTEUR - TABLE RESUME -----
  RESUME.table <- data.table(Nb_list = NA,Seuil = NA,Nb_esp_communs = NA, Nb_liste_flag_A = NA,Nb_liste_flag_B = NA,Nb_liste_flag_C = NA,Nb_liste_flag_D = NA,
                             Nb_liste_1_flag = NA, Nb_list_refusee = NA, Nb_liste_refuse_suspicion = NA, Nb_obs_suspicion = NA)


for(SEUIL in c(seq(50,95,5),seq(96,99,1))/100){ # seuil a teste lors de la determination des especes communes
  
# Formation des attendus theoriques -----
# subsetting selon les grands contributeurs - sans prendre en compte les ecoregions
  champ <- aggregate(Liste_complete ~ Observateur,data=epoc.bary, FUN=sum)
  champ$part_totale <- champ$Liste_complete / sum(champ$Liste_complete)*100
  
  champ.id <- champ[champ$part_totale > 1,] # champion = observateur contribuant a plus de 1% des EPOCs
  champ.bary <- merge(x = epoc.bary,y=champ.id,by="Observateur")
  # verif
  length(unique(champ.bary$ID_liste)) == sum(champ.id$Liste_complete) # TRUE
  
  
  # recuperation du dtf des communautes d'oiseaux detecte par les champions
  champ.oiso <- merge(x = champ.bary,y=epoc.oiso,by="ID_liste",all.x=T)
  # verif
  length(unique(champ.bary$ID_liste)) == length(unique(champ.oiso$ID_liste)) # TRUE
  
  
# NETWORK - igraph ----
    champ.cortege <- graph.data.frame(champ.oiso[,c("Nom_espece","Departement")], directed = F) # ou ID_liste

  # calcul d'indices - degree
    cortege_degree <- degree(champ.cortege,normalized = T)
  # classement des especes (= retrait des nodes departements)
    cortege_degree2 <- cortege_degree[which(names(cortege_degree) %in% unique(champ.oiso$Nom_espece))]
    name.oiso.com <- names(cortege_degree2[which(cortege_degree2 > as.numeric(quantile(cortege_degree2,SEUIL)))])
  
    
# TIRAGE ALEATOIRE <=> FREQUENCE D'OCCURENCE / DETERMINATION COMMUNS ----
  cat("Debut tirages aleatoire - formation des courbes theoriques pour le seuil : ",SEUIL)
  # mise en place du tirage ----
    # recuperation des frequence d'occurence
    champ.esp <- plyr::count(champ.oiso$Nom_espece)
    colnames(champ.esp) <- c("Nom_espece","count")
    
    champ.esp$prob <- champ.esp$count/length(unique(champ.oiso$ID_liste)) # length(...) = nb de liste realise par les grands observateurs
    
    # ajout de la determination communs/non-communs
    champ.esp$communs <- as.numeric(champ.esp$Nom_espece %in% name.oiso.com)

  # tirage aleatoire sans remise ----
    tir.1esp <- c();       tir.2esp <- c()
    tir.3esp <- c();       tir.4esp <- c()
    tir.5esp <- c();       tir.6esp <- c()
    tir.7esp <- c();       tir.8esp <- c()
    tir.9esp <- c();       tir.10esp <- c()
    tir.11esp <- c();       tir.12esp <- c()
    tir.13esp <- c();       tir.14esp <- c()
    tir.15esp <- c();       tir.16esp <- c()
    tir.17esp <- c();       tir.18esp <- c()
    tir.19esp <- c();       tir.20esp <- c()
    tir.21esp <- c();       tir.22esp <- c()
    tir.23esp <- c();       tir.24esp <- c()
    tir.25esp <- c();       tir.26esp <- c()
    tir.27esp <- c();       tir.28esp <- c()
    tir.29esp <- c();       tir.30esp <- c()
    tir.31esp <- c();       tir.32esp <- c()
    tir.33esp <- c();       tir.34esp <- c()
    tir.35esp <- c()
    
    for(i in 1:10000){
      tir.1esp <- append(tir.1esp,as.character(sample(x = champ.esp$Nom_espece,size=1,replace=FALSE,prob = champ.esp$prob)))
      tir.2esp <- append(tir.2esp,as.character(sample(x = champ.esp$Nom_espece,size=2,replace=FALSE,prob = champ.esp$prob)))
      tir.3esp <- append(tir.3esp,as.character(sample(x = champ.esp$Nom_espece,size=3,replace=FALSE,prob = champ.esp$prob)))
      tir.4esp <- append(tir.4esp,as.character(sample(x = champ.esp$Nom_espece,size=4,replace=FALSE,prob = champ.esp$prob)))
      tir.5esp <- append(tir.5esp,as.character(sample(x = champ.esp$Nom_espece,size=5,replace=FALSE,prob = champ.esp$prob)))
      tir.6esp <- append(tir.6esp,as.character(sample(x = champ.esp$Nom_espece,size=6,replace=FALSE,prob = champ.esp$prob)))
      tir.7esp <- append(tir.7esp,as.character(sample(x = champ.esp$Nom_espece,size=7,replace=FALSE,prob = champ.esp$prob)))
      tir.8esp <- append(tir.8esp,as.character(sample(x = champ.esp$Nom_espece,size=8,replace=FALSE,prob = champ.esp$prob)))
      tir.9esp <- append(tir.9esp,as.character(sample(x = champ.esp$Nom_espece,size=9,replace=FALSE,prob = champ.esp$prob)))
      tir.10esp <- append(tir.10esp,as.character(sample(x = champ.esp$Nom_espece,size=10,replace=FALSE,prob = champ.esp$prob))) 
      tir.11esp <- append(tir.11esp,as.character(sample(x = champ.esp$Nom_espece,size=11,replace=FALSE,prob = champ.esp$prob))) 
      tir.12esp <- append(tir.12esp,as.character(sample(x = champ.esp$Nom_espece,size=12,replace=FALSE,prob = champ.esp$prob))) 
      tir.13esp <- append(tir.13esp,as.character(sample(x = champ.esp$Nom_espece,size=13,replace=FALSE,prob = champ.esp$prob)))  
      tir.14esp <- append(tir.14esp,as.character(sample(x = champ.esp$Nom_espece,size=14,replace=FALSE,prob = champ.esp$prob))) 
      tir.15esp <- append(tir.15esp,as.character(sample(x = champ.esp$Nom_espece,size=15,replace=FALSE,prob = champ.esp$prob)))  
      tir.16esp <- append(tir.16esp,as.character(sample(x = champ.esp$Nom_espece,size=16,replace=FALSE,prob = champ.esp$prob))) 
      tir.17esp <- append(tir.17esp,as.character(sample(x = champ.esp$Nom_espece,size=17,replace=FALSE,prob = champ.esp$prob))) 
      tir.18esp <- append(tir.18esp,as.character(sample(x = champ.esp$Nom_espece,size=18,replace=FALSE,prob = champ.esp$prob))) 
      tir.19esp <- append(tir.19esp,as.character(sample(x = champ.esp$Nom_espece,size=19,replace=FALSE,prob = champ.esp$prob)))  
      tir.20esp <- append(tir.20esp,as.character(sample(x = champ.esp$Nom_espece,size=20,replace=FALSE,prob = champ.esp$prob))) 
      tir.21esp <- append(tir.21esp,as.character(sample(x = champ.esp$Nom_espece,size=21,replace=FALSE,prob = champ.esp$prob)))  
      tir.22esp <- append(tir.22esp,as.character(sample(x = champ.esp$Nom_espece,size=22,replace=FALSE,prob = champ.esp$prob))) 
      tir.23esp <- append(tir.23esp,as.character(sample(x = champ.esp$Nom_espece,size=23,replace=FALSE,prob = champ.esp$prob))) 
      tir.24esp <- append(tir.24esp,as.character(sample(x = champ.esp$Nom_espece,size=24,replace=FALSE,prob = champ.esp$prob))) 
      tir.25esp <- append(tir.25esp,as.character(sample(x = champ.esp$Nom_espece,size=25,replace=FALSE,prob = champ.esp$prob)))  
      tir.26esp <- append(tir.26esp,as.character(sample(x = champ.esp$Nom_espece,size=26,replace=FALSE,prob = champ.esp$prob))) 
      tir.27esp <- append(tir.27esp,as.character(sample(x = champ.esp$Nom_espece,size=27,replace=FALSE,prob = champ.esp$prob))) 
      tir.28esp <- append(tir.28esp,as.character(sample(x = champ.esp$Nom_espece,size=28,replace=FALSE,prob = champ.esp$prob))) 
      tir.29esp <- append(tir.29esp,as.character(sample(x = champ.esp$Nom_espece,size=29,replace=FALSE,prob = champ.esp$prob))) 
      tir.30esp <- append(tir.30esp,as.character(sample(x = champ.esp$Nom_espece,size=30,replace=FALSE,prob = champ.esp$prob))) 
      tir.31esp <- append(tir.31esp,as.character(sample(x = champ.esp$Nom_espece,size=31,replace=FALSE,prob = champ.esp$prob))) 
      tir.32esp <- append(tir.32esp,as.character(sample(x = champ.esp$Nom_espece,size=32,replace=FALSE,prob = champ.esp$prob))) 
      tir.33esp <- append(tir.33esp,as.character(sample(x = champ.esp$Nom_espece,size=33,replace=FALSE,prob = champ.esp$prob))) 
      tir.34esp <- append(tir.34esp,as.character(sample(x = champ.esp$Nom_espece,size=34,replace=FALSE,prob = champ.esp$prob))) 
      tir.35esp <- append(tir.35esp,as.character(sample(x = champ.esp$Nom_espece,size=35,replace=FALSE,prob = champ.esp$prob))) 
      
      
    }
    
  # changement de format de l'objet : vecteur --> matrixx
    tir.1esp <- matrix(tir.1esp) ;    tir.2esp <- matrix(tir.2esp,ncol=2,byrow=T)
    tir.3esp <- matrix(tir.3esp,ncol=3,byrow=T) ;    tir.4esp <- matrix(tir.4esp,ncol=4,byrow=T)
    tir.5esp <- matrix(tir.5esp,ncol=5,byrow=T) ;    tir.6esp <- matrix(tir.6esp,ncol=6,byrow=T)
    tir.7esp <- matrix(tir.7esp,ncol=7,byrow=T) ;    tir.8esp <- matrix(tir.8esp,ncol=8,byrow=T)
    tir.9esp <- matrix(tir.9esp,ncol=9,byrow=T) ;    tir.10esp <- matrix(tir.10esp,ncol=10,byrow=T)
    tir.11esp <- matrix(tir.11esp,ncol=11,byrow=T) ;    tir.12esp <- matrix(tir.12esp,ncol=12,byrow=T)
    tir.13esp <- matrix(tir.13esp,ncol=13,byrow=T) ;    tir.14esp <- matrix(tir.14esp,ncol=14,byrow=T)
    tir.15esp <- matrix(tir.15esp,ncol=15,byrow=T) ;    tir.16esp <- matrix(tir.16esp,ncol=16,byrow=T)
    tir.17esp <- matrix(tir.17esp,ncol=17,byrow=T) ;    tir.18esp <- matrix(tir.18esp,ncol=18,byrow=T)
    tir.19esp <- matrix(tir.19esp,ncol=19,byrow=T) ;    tir.20esp <- matrix(tir.20esp,ncol=20,byrow=T)
    tir.21esp <- matrix(tir.21esp,ncol=21,byrow=T) ;    tir.22esp <- matrix(tir.22esp,ncol=22,byrow=T)
    tir.23esp <- matrix(tir.23esp,ncol=23,byrow=T) ;    tir.24esp <- matrix(tir.24esp,ncol=24,byrow=T)
    tir.25esp <- matrix(tir.25esp,ncol=25,byrow=T) ;    tir.26esp <- matrix(tir.26esp,ncol=26,byrow=T)
    tir.27esp <- matrix(tir.27esp,ncol=27,byrow=T) ;    tir.28esp <- matrix(tir.28esp,ncol=28,byrow=T)
    tir.29esp <- matrix(tir.29esp,ncol=29,byrow=T) ;    tir.30esp <- matrix(tir.30esp,ncol=30,byrow=T)
    tir.31esp <- matrix(tir.31esp,ncol=31,byrow=T) ;    tir.32esp <- matrix(tir.32esp,ncol=32,byrow=T)
    tir.33esp <- matrix(tir.33esp,ncol=33,byrow=T) ;    tir.34esp <- matrix(tir.34esp,ncol=34,byrow=T)
    tir.35esp <- matrix(tir.35esp,ncol=35,byrow=T)

    
# FORMATION DES COURBES THEORIQUES ----
  row.names(champ.esp) <- champ.esp$Nom_espece
  # part especes communes ----
    tab.qt.global.part <- data.frame() # pour stack les 35 moyennes des quantiles
  
    for(j in 1:35){
      nb.esp <- j
      
      tab.qt <- data.frame() # dtf 95%
      
      vec.tir <- as.vector(get(paste0("tir.",nb.esp,"esp")))
      
      vec.communs <- champ.esp[vec.tir,"communs"]
      tab.communs <- matrix(vec.communs,nrow = 10000)
      
      for(i in 1:100){
        test <- sample(x = row(tab.communs),size=1000)
        tab.communs.boot <- as.matrix(tab.communs[test,])
        tab.communs.boot <- cbind(tab.communs.boot,rowSums(tab.communs.boot/ncol(tab.communs.boot))) # part des especes communes dans une liste
        
        tab.communs.boot.qt <- quantile(tab.communs.boot[,ncol(tab.communs.boot)],c(0.025,0.5,0.975)) # montre 95% des data
        
        min_max <- c(min(tab.communs.boot[,ncol(tab.communs.boot)]),max(tab.communs.boot[,ncol(tab.communs.boot)]))
        
        tab.communs.boot.qt <- append(tab.communs.boot.qt,min_max)
        
        tab.qt <- rbind(tab.qt,tab.communs.boot.qt)
        
      }
      
      tab.qt.global.part <- rbind(tab.qt.global.part,apply(X = tab.qt,2,FUN=mean))
      cat(nb.esp," /"," 35\n")
      
    }
    
    # homogeineisation des noms de colonnes
    colnames(tab.qt.global.part) <- c("borne_inf","mediane","borne_sup","min","max")
      
    # visualisation de la courbe
      plot.part <- ggplot(tab.qt.global.part) + geom_point(aes(x = c(rep(1:35)),y=mediane,ymin=0.75)) + geom_line(aes(x = c(rep(1:35)),y=mediane)) +
        geom_ribbon(aes(x=c(rep(1:35)),ymin=borne_inf,ymax=borne_sup),alpha=0.5) + ggtitle("Part des especes communes dans la listes (95%)",
                                                                                           paste0("Seuil de determination des especes 'communes' = ", SEUIL)) + 
        geom_ribbon(aes(x=c(rep(1:35)),ymin=min,ymax=max),alpha=0.15)+
        xlab("Nombre d'especes par listes") + ylab("Part en %")
      
      assign(x = paste0("plot.part_",SEUIL), value = plot.part,
       envir = globalenv())
      
  # probabilite d'avoir au moins 1 espece communes ----
    champ.esp$communs <- as.logical(champ.esp$Nom_espece %in% name.oiso.com) # facilite l'execution du apply(X,1,any)
    tab.qt.global.prob <- data.frame() # pour stack les 35 moyennes des quantiles
    
    for(j in 1:35){
      nb.esp <- j
      
      tab.qt <- data.frame()
      
      vec.tir <- as.vector(get(paste0("tir.",nb.esp,"esp")))
      
      vec.communs <- champ.esp[vec.tir,"communs"]
      tab.communs <- matrix(vec.communs,nrow = 10000)
      
      for(i in 1:100){
        test <- sample(x = row(tab.communs),size=1000)
        tab.communs.boot <- tab.communs[test,]
        tab.communs.boot <- as.numeric(apply(as.matrix(tab.communs.boot),1,any))
        tab.communs.boot <- sum(tab.communs.boot)/length(tab.communs.boot) # part des especes communes dans une liste
        
        tab.qt <- rbind(tab.qt,tab.communs.boot)
      }
      
      tab.qt.global.prob <- rbind(tab.qt.global.prob,quantile(x = tab.qt[,1],c(0.025,0.5,0.975)))
      cat(nb.esp," /"," 35\n")
      
    }
    
    # homogeineisation des noms de colonnes
    colnames(tab.qt.global.prob) <- c("borne_inf","mediane","borne_sup")
    tab.qt.global.prob$diversite <- c(1:nrow(tab.qt.global.prob))
      
    # detection du nb d'especes minimum dans la liste --> utilise dans les flags
      prob.minimum.sp <- min(tab.qt.global.prob[which(tab.qt.global.prob$borne_inf > 0.975),"diversite"])
    
    # visualisation de la courbe
    plot.prob <- ggplot(tab.qt.global.prob) + geom_point(aes(x = c(rep(1:35)),y=mediane,ymin=0.75)) + geom_line(aes(x = c(rep(1:35)),y=mediane)) +
      geom_ribbon(aes(x=c(rep(1:35)),ymin=borne_inf,ymax=borne_sup),alpha=0.5) +
      geom_vline(xintercept = prob.minimum.sp,color="red") +
      ggtitle("Proba d'avoir au moins une espece communes dans les listes",
              paste0("Seuil de determination des especes 'communes' = ", SEUIL,
                     "\nNb d'especes permettant la distinction des cas 'many rare' & 'only rare low div' : ",prob.minimum.sp)) + 
        xlab("Nombre d'especes par listes") + ylab("Probabilite")

    assign(x = paste0("plot.prob_",SEUIL), value = plot.prob,
     envir = globalenv())

          
# REGROUPEMENT SELON ECOREGIONS / GESTION DES ZONES TAMPONS ----
  # Intersection points d'observation et region
    bary.reg <- st_intersects(x=epoc.bary_sf,y=eco.reg.buf,sparse=FALSE)
    bary.reg <- as.data.frame(bary.reg) # dtf contenant les points et les regions associees a leur localisation

  # gestion forme du dtf
    colnames(bary.reg) <- eco.reg$ECO_NAME
    bary.reg$ID_liste <- epoc.bary$ID_liste
    
    bary.reg <- as.data.frame(plyr::join(epoc.bary[,c("ID_liste","X_barycentre_L93","Y_barycentre_L93")],bary.reg,by="ID_liste"))    
  
    for(i in grep(" ",colnames(bary.reg))){ # detection des ecoregions (= colonnes w/ " ") --> transformation logique to numeric
      bary.reg[,i] <- as.numeric(bary.reg[,i])
    }
  
  # gestion des epocs realise en hautes-altitudes
    det.haute.alt <- as.data.frame(epoc.bary[epoc.bary$Altitude_moyenne > 1200,"ID_liste"]) ; det.haute.alt <- det.haute.alt$ID_liste
    
    bary.reg$`Hautes altitudes` <- bary.reg$`Alps conifer and mixed forests` # (<- 0) ==> $`Alps...` = contremesure vs sous-echantillonnage de l'ecoregion alps_connifer w/ liste sous 1200m d'altitude
    bary.reg[bary.reg$ID_liste %in% det.haute.alt,grep(" ",colnames(bary.reg))] <- 0
    bary.reg[bary.reg$ID_liste %in% det.haute.alt,"Hautes altitudes"] <- 1
    
    bary.reg$`Alps conifer and mixed forests` <- NULL # fin de la contremesure vs sous-echantillonnage de l'ecoregion alps_connifer
  
  # Information sur les zones tampons (cas ou un point d'obs recouvre plus d'un polygone de region)
    bary.reg$nb_intersection <- 0
    bary.reg[,"nb_intersection"] <- rowSums(bary.reg[,grep(" ",colnames(bary.reg))])
    
    

# FORMATION DES LISTES D'ESPECES COMMUNES par region + FLAGGING [cas hors frontieres] -----
  # initialisation pour la fonction determination_communs_by_regions
    epoc.oiso$diversite <- 1 # indice du nb d'espece dans la liste
    tab.qt.global.part$diversite <- c(rep(1:nrow(tab.qt.global.part))) # permet de comparer les part d'especes communes theoriques vs empiriques
    
    bary.1reg <- bary.reg[bary.reg$nb_intersection == 1,] # etablissement des listes communes d'especes a partir des listes realiser au coeur de ces region
    
    
    for(i in grep(" ",colnames(bary.1reg))){ # selection des colonnes ecoregions (seule $ w/ " " inclus)
      reg1.tmp <- bary.1reg[,c(1,i)] # formation du dtf regroupant ID_Liste et la presence/absence d'obs de la region i
      
      determination_communs_by_regions_ETUDE_SEUIL(dtf.reg1 = reg1.tmp,prob.minimum.sp = prob.minimum.sp,seuil = SEUIL)
      
      cat(colnames(bary.1reg)[i]," -- DONE ","\n\n")
    }
    
    
    
# FORMATION DES LISTES D'ESPECES COMMUNES [cas zone tampon] ----
  # formation d'un dtf regroupant les flaggs d'especes (communs/rares) selon les zones tampons des listes -----
    vec.reg <- colnames(bary.reg)[grep(" ",colnames(bary.reg))]  # recup' des noms des polygones
    list.region <- bary.reg[,c("ID_liste",vec.reg)] # formation d'une table ID_liste / presence/absence d'une liste dans une polygone
    
    list.region_l <- reshape2::melt(list.region, id.vars = "ID_liste") # formation d'un long dtf regroupant la variable nom_polygone dans une colonne (-> x5 nb ligne ==> car 5 polygones)
    colnames(list.region_l)[2:3] <- c("regions","intersect") # rename des var (+ de lisibilite)
    list.region_l <- subset(list.region_l, intersect == 1) # selection des listes ayant intersecte le polygone (-> liste realise dans zone tampon de 3 polygones ==> 3 lignes)

    
  # Mise en commun de la determination communs/non-communs selon les ecoregions ----
    # globalisation de mes dtf communautes d'oiseaux par polygones
      oiso.reg.all <- data.table::rbindlist(mget(x = ls(pattern = "oiso.reg.[A-Z]"))) # recuperation des variables creer par determination_communs_by_regions
    
    # Formation de la table regroupant les especes considerees comme communes selon les ecoregions
      oiso.reg.all.communs <- oiso.reg.all[oiso.reg.all$communs == 1,] # selection des especes qualifiees comme communes
      oiso.reg.all.communs <- unique(oiso.reg.all.communs[,c("Nom_espece","communs","regions")]) # retrait des doublons
    
      
    # Ajout information determination communs/non-communs aux ID_liste ----
      list.region_l <- inner_join(list.region_l,oiso.reg.all.communs)  # tel region -> quelles especes etaient communs/rare ?
      
      list.region.espece <- unique(list.region_l[,c("ID_liste","Nom_espece","communs")]) # VS flagging communs/rare d'une espece pour une liste de zone tampon
      
      
    # Selection des listes realisee dans les zones tampons / join avec les informations precedentes et pose des flags par listes/observateur -----
      bary.tampon.reg <- bary.reg[bary.reg$nb_intersection != 1,"ID_liste"]
      det.list.oiso.tampon <- epoc.oiso$ID_liste %in% bary.tampon.reg
      
      epoc.oiso.tampon <- epoc.oiso[det.list.oiso.tampon,]
      epoc.oiso.tampon <- left_join(x=epoc.oiso.tampon[,c("ID_liste","Observateur","Nom_espece","Nom_latin")],list.region.espece) # dtf des especes communes/rares attendue par liste (selon la zone tampon)
      
      epoc.oiso.tampon[which(is.na(epoc.oiso.tampon$communs)),"communs"] <- 0 # $communs == NA --> especes non communes observees dans la liste
      
    
# PREPARATIF du flagging des listes (= calcul part d'espece communes / presence d'au moins une espece communes) -----
  epoc.oiso.tampon$diversite <- 1 # ajout d'une colonne pour calculer le nb d'espece vues dans une liste
  epoc.oiso.tampon$communs_logical <- as.logical(epoc.oiso.tampon$communs)
  
  # Formation du dtf regroupant les flags par listes
    list.reg.tampon <- aggregate(diversite ~ Observateur + ID_liste,
                                 data = epoc.oiso.tampon,
                                 FUN = sum)
  
  # flag de la part d'especes communes
    flag.prep.part.comm <- aggregate(communs ~ ID_liste, data = epoc.oiso.tampon, sum)
    colnames(flag.prep.part.comm) <- c("ID_liste","nb_communs")
  
  # flag presence d'au moins une espece commune dans la liste
    flag.prep.least_1_comm <- aggregate(communs_logical ~ ID_liste, data = epoc.oiso.tampon, any)
    colnames(flag.prep.least_1_comm) <- c("ID_liste","least_1_communs")
  
  # join au dtf (list.reg.tampon + flagging des listes)
    list.reg.tampon <- plyr::join(list.reg.tampon,flag.prep.part.comm,by="ID_liste")
    list.reg.tampon$part_communs <- list.reg.tampon$nb_communs / list.reg.tampon$diversite
    
    list.reg.tampon <- plyr::join(list.reg.tampon,flag.prep.least_1_comm,by="ID_liste")

      
      
# FLAGGING -----
  # Flag many_rare (Liste a forte diversite [>4 especes] avec que des especes rares)
    list.reg.tampon$flag_many_rare <- 0
    
    id.list.rare <- which(list.reg.tampon$diversite >= prob.minimum.sp & list.reg.tampon$least_1_communs == FALSE)
    list.reg.tampon[id.list.rare,"flag_many_rare"] <- 1   
    
  # Flag only_rare_low_dic (Liste de faible diversite [< 4 especes] avec que des especes rares)
    list.reg.tampon$flag_only_rare_low_div <- 0
    
    id.list.rare.low <- which(list.reg.tampon$diversite < prob.minimum.sp & list.reg.tampon$least_1_communs == FALSE)
    list.reg.tampon[id.list.rare.low,"flag_only_rare_low_div"] <- 1
    
  # Flag scarce_communs (part d'especes communes moins importante que l'attendue)
    list.reg.tampon$flag_scarce_commun <- 0
    
    comp.communs <- plyr::join(list.reg.tampon[,c("ID_liste","diversite","part_communs")],tab.qt.global.part,by="diversite")
    list.emp_th <- comp.communs[which(comp.communs$part_communs <= comp.communs$borne_inf),"ID_liste"]
    
    id.list.less.comm <- list.reg.tampon$ID_liste %in% list.emp_th
    list.reg.tampon[which(id.list.less.comm == TRUE),"flag_scarce_commun"] <- 1
    
    
  # Flag premiere espece rencontree
    # ajout des categories <=> evaluation de jeremy
    epoc.oiso.tampon <- plyr::join(epoc.oiso.tampon,cate.esp2,by="Nom_espece") # join des categories de rarete experte selon le nom d'espece
    epoc.oiso.tampon[which(is.na(epoc.oiso.tampon$Decision)),"Decision"] <- 1 # cas ou une espece ne serait pas identifie (-> presummer rare)
    
    # incrementation -> detection de la 1ere observation de chaque liste
    epoc.oiso.cate_dt <- data.table(epoc.oiso.tampon)
    epoc.oiso.cate_dt <- epoc.oiso.cate_dt[, group_increment := 1:.N, by = "ID_liste"]
    epoc.oiso.tampon <- as.data.frame(epoc.oiso.cate_dt)
    
    # selection de la 1ere observation de chaque liste
    first.obs <- which(epoc.oiso.tampon$group_increment == 1)
    list.oiso.cate.tampon <- epoc.oiso.tampon[first.obs,c("ID_liste","Observateur","Nom_espece","Decision","group_increment","communs")]   
    
    # flagging moduler (espece de categorie 3 flaggees <=> non considere comme communes) 
    list.oiso.cate.tampon$flag_first_obs_unusual <- 0
    list.oiso.cate.tampon[list.oiso.cate.tampon$Decision == 2,"flag_first_obs_unusual"] <- 1
    
    list.reg.tampon <- plyr::join(list.reg.tampon,list.oiso.cate.tampon[,c("ID_liste","flag_first_obs_unusual")],by="ID_liste")

    
# RASSEMBLEMENT DES FLAGS ----
  # globalisation( list.flag) des liste et des flags associees  
    list.flag <- as.data.frame(data.table::rbindlist(mget(x = ls(pattern = "list.reg.[A-Z]")))) # regroupement des donnees de listes flaggees selon les differentes ecoregion
    list.flag <- rbind(list.flag[,-c(grep(pattern = "nb_liste|regions",colnames(list.flag)))],list.reg.tampon) # rajout des donnes de flagging des listes issues des zones tampons
      
  # formation du flag meta
    list.flag$flag_meta <- rowSums(list.flag[,grep("flag",colnames(list.flag))])
    list.flag[which(list.flag$flag_meta > 1),"flag_meta"] <- 1
      
      
  # rassemblement sur les observateurs -----
    list.flag$nb_liste <- 1 # preparation au rassemblement sur les observateurs
    observateur.flag <- aggregate(cbind(nb_liste,flag_many_rare,flag_only_rare_low_div,flag_scarce_commun,flag_first_obs_unusual) ~ 
                                    Observateur,
                                  data=list.flag,
                                  FUN = sum)
    
    
    # calcul de la part des listes flaggees
      observateur.flag$part_many_rare <- observateur.flag$flag_many_rare / observateur.flag$nb_liste
      observateur.flag$part_only_rare <- observateur.flag$flag_only_rare / observateur.flag$nb_liste
      observateur.flag$part_scarce_commun <- observateur.flag$flag_scarce_commun / observateur.flag$nb_liste
      observateur.flag$part_first_obs_unusual <- observateur.flag$flag_first_obs_unusual / observateur.flag$nb_liste
      
      
# VISUALISATION-PLOT : FLAGS ~ NB_EPOC -----
  # preparatif (calcul des lignes rouges + restriction de l'axe des abcisses)
    name.champ <- as.character(unique(champ.bary$Observateur))
    detect.champ <-observateur.flag$Observateur %in% name.champ # detection des lignes avec les champions
    
    max.champ.flag.many.rare <- max(observateur.flag[which(detect.champ == TRUE),"part_many_rare"])
    max.champ.flag.only.rare <- max(observateur.flag[which(detect.champ == TRUE),"part_only_rare"])
    max.champ.flag.scarce.communs <- max(observateur.flag[which(detect.champ == TRUE),"part_scarce_commun"])
    max.champ.flag.first.obs <- max(observateur.flag[which(detect.champ == TRUE),"part_first_obs_unusual"])
  
    observateur.flag.nochamp <- observateur.flag[which(detect.champ == FALSE),]            
  
  # plot graphs ----
    flag1 <- ggplot(observateur.flag.nochamp,aes(x = nb_liste,y= part_scarce_commun)) +
      geom_jitter() + 
      geom_hline(yintercept = max.champ.flag.scarce.communs,color="red") +
      ylab("Proportion de listes flaggees") +
      xlab("Nombre d'EPOC") +
      ggtitle(paste0("Repartition du flag - A (moins de communs que l'attendu)\nPar observateurs (Sans champions)\n",
                     "Maximum champions : ",round(max.champ.flag.scarce.communs,5),
                     "\nSeuil determination communs : ",SEUIL," / Nb listes flaggees : ", sum(list.flag$flag_scarce_commun)))
    
    
    flag2 <- ggplot(observateur.flag.nochamp,aes(x = nb_liste,y= part_only_rare)) +
      geom_jitter() +
      geom_hline(yintercept = max.champ.flag.only.rare,color="red") +
      ylab("Proportion de listes flaggees") +
      xlab("Nombre d'EPOC") +
      ggtitle(paste0("Repartition du flag - B (0 communs, trop de rare - faible diversite)\nPar observateurs (Sans champions)\n",
                     "Maximum champions : ",round(max.champ.flag.only.rare,5),
                     "\nSeuil determination communs : ",SEUIL," / Nb listes flaggees : ", sum(list.flag$flag_only_rare_low_div)))
      
 
    flag3 <- ggplot(observateur.flag.nochamp,aes(x =nb_liste,y= part_many_rare)) +
      geom_jitter() + 
      geom_hline(yintercept = max.champ.flag.many.rare, color="red") +
      ylab("Proportion de listes flaggees") +
      xlab("Nombre d'EPOC") +
      ggtitle(paste0("Repartition du flag - C (0 communs, trop de rare) \nPar observateurs (Sans champions)\n",
                     "Maximum champions : ",round(max.champ.flag.many.rare,5),
                     "\nSeuil determination communs : ",SEUIL," / Nb listes flaggees : ", sum(list.flag$flag_many_rare)))
    
    
    flag4 <- ggplot(observateur.flag.nochamp,aes(x = nb_liste,y= part_first_obs_unusual)) +
      geom_jitter() + 
      geom_hline(yintercept = max.champ.flag.first.obs,color="red") +
      ylab("Proportion de listes flaggees") +
      xlab("Nombre d'EPOC") +
      ggtitle(paste0("Repartition du flag - D (1ere espece observee anecdotique)\nPar observateurs (Sans champions)\n",
                     "Maximum champions : ",round(max.champ.flag.first.obs,5),
                     "\nSeuil determination communs : ",SEUIL," / Nb listes flaggees : ", sum(list.flag$flag_first_obs_unusual)))
    
  # plot groupe des flags
  plot.all.flag <- ggpubr::ggarrange(flag1,flag2,flag3,flag4)
  assign(x = paste0("plot.all.flag_",SEUIL),value = plot.all.flag,envir = globalenv())
      

        
# "SUSPICION" ----
# IDEE :
# rm des listes flaggées many_rare (impossible) + detection des observateurs de ces listes
# si ces observateurs ont des listes flaggées only_rare_low_div (-> rm, car manque de confiance)
# formation d'un jeu de données annexes en enlevant leurs listes flaggées scarce/1st obs --> evaluation du poids
  
  # detection des observateurs avec part des listes flaggées "many_rare" superieur au max des champions ----
    bad.observateur <- as.vector(observateur.flag[which(observateur.flag$part_many_rare > max.champ.flag.many.rare),"Observateur"])     
    
    list.flag.bad.observateur <- list.flag[list.flag$Observateur %in% bad.observateur,] # récuperation de l'ensemble des listes effectue par ces observateurs
  
    # detection liste flaggees only_rare_low_div
    det.list.only.rare.bad.observateur <- list.flag.bad.observateur[which(list.flag.bad.observateur$flag_only_rare_low_div == 1),"ID_liste"]
    # detection liste flaggees scarce_commun & 1st_obs_unusual
    det.list.scarce_first.bad.observateur <- list.flag.bad.observateur[which(list.flag.bad.observateur$flag_scarce_commun == 1 | list.flag.bad.observateur$flag_first_obs_unusual == 1),"ID_liste"]
    
    det.list.flag.bad.observateur <- base::union(det.list.only.rare.bad.observateur,det.list.scarce_first.bad.observateur) #union des listes only/scarce&first_obs
  
  # Tagging listes flaggées many_rare (tout observateur confondu) -----
  list.flag$accepted <- 1
  list.flag[which(list.flag$flag_many_rare == 1),"accepted"] <- 0
  
  # Tagging des listes flaggées des observateurs suspicieux (part de liste flaggée many_are > aux champions) ----
  list.flag$strict <- 1
  
  list.flag[which(list.flag$ID_liste %in% det.list.scarce_first.bad.observateur),"strict"] <- 0
    
  
# RECUPERATION INFOS -> REMPLISSAGE TABLE RESUME -----
  RESUME.table.tmp <- data.table(Nb_list = nrow(list.flag),
                                 Seuil = SEUIL,
                                 Nb_esp_communs = length(name.oiso.com),
                                 Nb_liste_flag_A = sum(list.flag$flag_scarce_commun),
                                 Nb_liste_flag_B = sum(list.flag$flag_only_rare_low_div),
                                 Nb_liste_flag_C = sum(list.flag$flag_many_rare),
                                 Nb_liste_flag_D = sum(list.flag$flag_first_obs_unusual),
                                 Nb_liste_1_flag = sum(list.flag$flag_meta),
                                 Nb_list_refusee = nrow(list.flag) - sum(list.flag$accepted), 
                                 Nb_liste_refuse_suspicion = nrow(list.flag) - sum(list.flag$strict), 
                                 Nb_obs_suspicion = length(bad.observateur))
  
  RESUME.table <- rbind(RESUME.table,RESUME.table.tmp)
  
  
  PLOT.PROB <- mget(x=ls(pattern = "plot.prob_"))
  PLOT.PART <- mget(x=ls(pattern = "plot.part_"))
  PLOT.ALL <- mget(x=ls(pattern = "plot.all.flag_"))
    
}




    
```

```{r save_plot_disk, include=FALSE,eval=FALSE}
# WARNING : check si eval=TRUE pour nouvelle sauvegarde
for(i in 1:length(PLOT.ALL)){
  ggsave(filename = paste0("C:/git/ODF/output/Etude_impact_seuil/",names(PLOT.ALL)[i],".jpeg"),
         plot = PLOT.ALL[[i]],
         device="jpeg",
         units = "in",
         width = 14,
         height = 13)
}

for(i in 1:length(PLOT.PART)){
  PLOT <- ggpubr::ggarrange(PLOT.PART[[i]],PLOT.PROB[[i]])
  
  ggsave(filename = paste0("C:/git/ODF/output/Etude_impact_seuil/",gsub("plot.part_","plot.part_prob_",names(PLOT.PART)[i]),".jpeg"),
         plot = PLOT,
         device="jpeg",
         units = "in",
         width = 13,
         height = 6)
  
}
```



## Etude de l'effet du seuil de détermination des espèces communes sur le filtrage des données
\  

### <u>Les grands contributeurs</u>

On rentre concrètement dans les données avec en premier lieu des informations sur les grands contributeurs d'EPOCS (Table 1.) ainsi que la répartition de leurs; observations.

```{r recap_table_champ, include=TRUE,echo=FALSE}
# recup' donnees
  TABLE.champ <- as.data.frame(champ.oiso)
  TABLE.champ <- TABLE.champ[,-grep("[.]y",colnames(TABLE.champ))] ; colnames(TABLE.champ) <- gsub(".x","",colnames(TABLE.champ)) # retrait suffixes du merge
  TABLE.champ[,"Observateur"] <- gsub("( [a-zA-Z]{1})(.+)","\\1",TABLE.champ$Observateur)

# manip'
  TABLE.champ <- TABLE.champ %>%
    group_by(Observateur) %>%
    mutate(`Nombre de listes` = n_distinct(ID_liste)) %>%
    mutate(`Nombre d'observations` = n()) %>%
    mutate(`Nombre d'especes differentes identifiees` = n_distinct(Nom_espece))
  TABLE.champ <- unique(TABLE.champ[,grep("Observateur| ",colnames(TABLE.champ))])
  TABLE.champ <- TABLE.champ[order(TABLE.champ$`Nombre de listes`,decreasing=T),]

# presentation
  knitr::kable(TABLE.champ,align = "c",caption = "Tableau 1. Informations sur les grands contributeurs (2017-2020)")
```

<center><u>*Fig 3. Répartition des EPOCs "Grands contributeurs" - Données 2017-2020*</u></center>\  
```{r carte_champs,include=TRUE,echo=FALSE,message=FALSE,fig.align="center"}
# load data spatial
fra.adm <- st_transform(st_read(dsn = "C:/Users/Travail/Desktop/Ressource QGis/france/adm/FRA_adm1.shp",quiet=T),crs=2154)
champ.bary_sf <- st_as_sf(champ.bary, coords = c("X_barycentre_L93","Y_barycentre_L93"), crs= 2154)
champ.bary_sf[,"Observateur"] <- gsub("( [a-zA-Z]{1})(.+)","\\1",champ.bary_sf$Observateur)

ggplot() +
  geom_sf(data = fra.adm, alpha = 0.75) +
  geom_sf(data=champ.bary_sf,aes(col = Observateur)) +
  labs(col = "Observateurs")
```


A l'aide du tableau et de la carte (fig 3.), on voit au sein même de ces contributeurs une forte différence d'effort d'échantillonnage et la faible répartition de celui-ci sur l'ensemble du territoire.\  



### <u>Courbes théoriques</u>

Voici les courbes obtenues avec les résultats issus de la méthode présentée en figure 2.\  

<center><u>*Fig 4. Evolution de la composition des listes en espèces "communes" selon le nombre d'espèce relevée par saisie*</u></center>\  
```{r visualisation_part_prob, include=TRUE,echo=FALSE,fig.keep="all",fig.show="animate", animation.hook = "gifski",interval=4,fig.width=13,fig.height=6}
for(i in 1:length(PLOT.PROB)){
  PLOT <- ggpubr::ggarrange(PLOT.PART[[i]],PLOT.PROB[[i]])
  print(PLOT)
  }

```

Les points noires correspondent aux valeurs moyennes obtenues après les 100 itérations (cf. fig 2), la zone gris foncé équivaut aux 95% de la distribution de ces valeurs et la zone gris claire, les valeurs minimales et maximales. L'axe verticale rouge, sur le graphique de la '*<u>probabilité d'obtention d'au moins 1 espèce commune dans les listes*</u>', représente le nombre d'espèces minimal au-delà duquel on considère que le manque d'observation d'espèce commune n'est pas lié au hasard (*p* > 0.975 -- *permet la distinction des cas B et C, voir plus bas*)\  

Les courbes (fig 4.) sont ensuite utilisées afin d'analyser le comportements des observateurs suivant différents cas :

<center><u>*Fig 5. Représentation des différents cas*</u></center>\  
```{r plot_exemple_cas, include = TRUE, echo=FALSE,out.width="85%",fig.align="center"}
knitr::include_graphics(path = "C:/git/ODF/output/Etude_impact_seuil/exemple_cas.png")
```


> + <u>Cas A :</u> L'observateur a identifié moins d'espèce que l'attendue (reflètent possiblement un choix de lieu à forte densité d'espèces) -- *flag scare communs*
>
> + <u>Cas B :</u> Les observateurs ayant identifiés peu d'espèce non détectés aucune espèces communes -- *flag only rare low diversity*
>
> + <u>Cas C :</u> Les observateurs ayant identifiés "beaucoup" d'espèces sans relever d'espèces communes (possible ommission d'espèce lors de la saisie) -- *flag many rare*
>
> + <u>Cas D :</u> Les observateurs ont débuté leur saisie par une espèce anecdotique (basé sur une liste d'espèces réalisée par Jérémy) -- *flag first obs unusual*

> <u>Fait à noter:</u> Certains flags ne sont pas indépendants (un EPOC avec peu d'espèce identifiés donc aucune n'est commune peu avoir le flag A et B simultanément)

\  \  \  

### <u>Répartition des flags selon le nombre de listes réalisées par les observateurs</u>

Le **"comportement observateur"** correspond au calcul la part des flags qu'un observateur à accumuler sur l'ensemble des EPOCs qu'il a réalisé. Les graphiques suivants nous montrent comment ce comportement évolue en fonction du nombre d'EPOC que l'observateur a effectué. La courbe horizontale rouge correspond à la part maximale des flags respectifs observés dans le groupe des "grands contributeurs" (cette valeur permettra de traiter la gestion des """"""*mauvais élèves*""""" par **suspicion** expliqué plus bas).

\  \  \  

<center><u>*Fig 6. Proportion des listes flagées par observateurs selon le nombre d'EPOC réalisés*</u></center>\  

```{r visualisation_flag_obs, include=TRUE,echo=FALSE,fig.keep="all",fig.show="animate",fig.width=13,fig.height=13, animation.hook = "gifski",interval=4}
for(i in 1:length(PLOT.ALL)){
  print(PLOT.ALL[[i]])
  }

```

> <u>NB :</u> Dans le cas B (aucune espèce rare mais peu d'espèce détectées) aux quantiles 0.50/0.55/0.60 le graphique montre une forte dispersion des points alors qu'aucune liste n'est flaggées, c'est dû à la fonction geom_jitter() qui n'arrive pas à les distribuer points car l'ensemble des parts est nulle.

\  \  \  

### <u>Effet du seuil sur le filtrage des listes</u>

##### <u>*Le filtrage des listes*</u>
Une liste est rejetée d'office lorsquelle a le flag C -- *many rare* (= possible omission d'espèce), considéré comme fortement peu probable selon la composition des listes.\  

La <u>**suspicion**</u> correspond à une gestion différentes pour les observateurs ayant réalisé plus de liste flaggées C -- *many rare* que le groupe des "grands contributeurs" (Tous les points au-dessus de la courbe rouge dans la fig 6. - C). Pour ces observateurs, aucune listes flagées n'est acceptées.
\  
Les deux prochains tableaux (Tableaux 2-3.) montrent l'effet des différents seuil sur le flagging des listes et le nombre de listes rejetées par la méthode.

```{r recap_table_resum, include=TRUE,echo=FALSE}
# Recup' + gestion data
RESUME.table$Nb_liste_refuse_suspicion <- RESUME.table$Nb_liste_refuse_suspicion - RESUME.table$Nb_list_refusee #correctif

# presentation
  knitr::kable(RESUME.table[-is.na(RESUME.table$Seuil),-"Nb_list"],
               align = "c",caption = "Tableau 2. Influence du seuil sur le filtrage des listes",
               col.names = c("Seuil","Nb espèces considerées communes",
                             "Nb listes flagées - Cas A","Nb listes flagées - Cas B","Nb listes flagées - Cas C",
                             "Nb listes flagées - Cas D","Nb listes avec au moins 1 flag","Nb listes refusées", "Nb listes refusées par suspicion",
                             "Nb observateurs considérés suspicieux"))

```

\  

```{r recap_table_resum_PART, include=TRUE,echo=FALSE}
# Recup' + retrait 1ere ligne de NA
RESUME.table.pres <- as.data.frame(RESUME.table[-is.na(RESUME.table$Seuil),])

# calcul des parts
RESUME.table.pres$Part_A <- round(RESUME.table.pres$Nb_liste_flag_A/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_B <- round(RESUME.table.pres$Nb_liste_flag_B/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_C <- round(RESUME.table.pres$Nb_liste_flag_C/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_D <- round(RESUME.table.pres$Nb_liste_flag_D/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_1_flag <- round(RESUME.table.pres$Nb_liste_1_flag/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_refusee <- round(RESUME.table.pres$Nb_list_refusee/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_refuse_suspicion <- round(RESUME.table.pres$Nb_liste_refuse_suspicion/RESUME.table.pres$Nb_list*100,2)
RESUME.table.pres$Part_obs <- round(RESUME.table.pres$Nb_obs_suspicion/ n_distinct(list.flag$Observateur)*100,2)



# presentation
  knitr::kable(RESUME.table.pres[,grep("Seuil|Part",colnames(RESUME.table.pres))],
               align = "c",caption = paste0("Tableau 3. Influence du seuil sur le filtrage des listes (pourcentage selon l'ensemble des listes = ",nrow(bary.reg),")"),
               col.names = c("Seuil",
                             "Part listes flagées - Cas A","Part listes flagées - Cas B","Part listes flagées - Cas C",
                             "Part listes flagées - Cas D","Part listes avec au moins 1 flag","Part listes refusées", "Part listes refusées par suspicion",
                             "Part observateurs considérés suspicieux"))

```

\  \  \  

***

##### <u>*Analyse des tableaux*</u>

On remarque plusieurs choses :  
  
\ **Pour le cas A -- *scarce commun*:** On remarque des oscillations dans le nombre de liste flaggées pour le cas A, elles proviennent de l'interraction complexe du seuil de détermination des espèces communes, étant donné qu'il varie selon 2 échelles. Premièrement avec le groupe des "grands contributeurs" pour former les courbes théoriqes de la figure 4, et deuxièmement au niveau des écorégions pour former les listes communes spécifiques. --- <u>*à voir s'il serait intéressant de faire varier sur ces deux échelles pour voir l'impact sur le filtrage*</u>
    
\ **Pour le cas B -- *only rare low div*:** On constate une augmentation constante du nombre de liste flaggées. Cette augmentation est provoqué par l'augmentation simultanée de la limite à partir de laquelle on considère que le manque d'observation d'espèce commune est liée au hasard (cf 4.), on augmente le nombre de liste pouvant être flaggé. Un des exemple de cette relation est le passage de 0.98 à 0.99 de seuil.  
<u>Liste flaggée B :</u> 4495 -> 8028 & <u>Nombre d'espèce :</u> 11 -> 18  

\ **Pour le cas C -- *many rare*:** L'augmentation constante du nombre de liste flagée corrèle avec la diminution du nombre d'espèce considèrée communes. Les oscillations du nombre de listes flaggées (*notamment la chute entre 0.98/0.99*) sont reliées à la limite à partir de laquelle on considère que le manque d'observation d'espèce commune est liée au hasard (cf 4.). Contrairement à l'explication du cas B, plus cette limite augmente, moins de liste rentre dans ce cas.  
La majorité des EPOCs ont moins de ~12-13 espèces saisies.
        
\ **Pour le cas D -- *first obs unusual*:** L'augmentation et le plateau observés correspondent à la structure de la liste faite par Jérémy. En effet, il avait un classement d'espèce selon la possibilité qu'elles soient communes selon 4 niveaux (1/2 : esp anecdotique; 3 : esp ***probablement commune, à condition d'être décrétée commune au sein de l'écorégion***; 4 : esp commune).<br />
L'augmentation du nombre de liste flaggées coïncide avec la diminution du nombre d'espèce communes (*les espèces atypiques de chaque région sont de moins en moins considérées communes, plus on augmente le seuil*), et le plateau correspond au fait que toutes les espèces ayant un indice de degré élevé sont considérées d'officecommunes par le classement de Jérémy, ne provoquant pas une augmentation du nombre de listes flaggées.
    
\ **Le nombre de liste refusé** est identique au nombre de liste flaggé selon le cas C -- *many rare*
  
\ Comme pour l'explication du cas A, l'oscillation du **nombre de liste refusé par suspicion** est du à l'intéraction complexe du seuil, vu que les listes flaggées A,B et D des observateurs *suspicieux* sont retirées du jeu de données.
  
\ **Le nombre d'observateur suspicieux** suit la tendance du cas C, étant donnée que les observateurs suspicieux correspondent aux observateurs ayant une part de leurs listes flaggées C plus importantes que celle des grands contributeurs (fig 6. - C).
  
***

### Le mot de la fin pour le moment*...*
  
Une des choses importantes à voir avant de continuer dans cette étude serait l'indice utiliser pour le seuil. Ici, je me suis basé sur le <u>degré</u> des différents noeuds d'un réseau, mais il existe plusieurs autres types d'indices sur les réseaux (voir, [Table 1. Lau et al., 2017](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/ecs2.1900)). Mon ressenti après l'utilisation du degré est que j'obtiens a peu prés les même résultat lorsque j'utilisais la fréquence d'occurence de l'espèce en guise de seuil.\  
<br />
J'avais cherché d'autres pistes pour tenter d'évaluer "l'aspect commun" des espèces, comme par exemple :<br />

>  (1) Le <u>**Coefficient de participation**</u> après clustering du réseau selon la méthode de Boris Leroy ([<u>8.1 du github/biogeonetworks</u>](https://github.com/Farewe/biogeonetworks)). -- *méthode intéressante, mais contraignante vu que le niveau de cluster doit être sélectionné à la main après avoir étudié la répartition des clusters*
>  (2) L'utilisation de l'<u>**impact factor**</u> ([Arellano et al., 2014](https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.1600-0587.2013.00546.x)). -- *je retrouvais des résultats pouvant être aberrant, possiblement du à un grand nombre d'observation d'une espèce dans un petit groupe de département*

<br />
Je trouve que l'un des problèmes dans la sélection de ces indices est la <u>**quantité d'information**</u> que l'on peut leur fournir vu qu'on les utilisent en début de process pour filtrer le jeu de données. -- *je ne sais pas s'il l'on peut utiliser les données de (distribution spatiale / d'abondance) des listes pour filtrer le jeu de données, afin de pouvoir calculer les aires de répartition et les effectifs de populations...*
  
<br />
Néanmoins, malgrè ces questions sur le choix des indices à utiliser pour le seuil. Après analyse du tableau -- *en considérant le degré comme bonne indice du seuil*. Je trouve que le seuil 0.97 est prometteur dans le sens où il maximise le nombre de listes rejetées et minimisent le nombre de listes considérées suspectes.




